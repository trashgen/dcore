Очередная реализация распределенной однораноговой сети. Проект учебный, который помимо непосредственно проекта будет использоваться
для того, чтобы потрогать как можно больше частей Go (на данный момент 10.3) руками и повоевать с багами :)
Никаких библиотек кроме стандартной части Go использоваться не будет. Вообще.
Единственный возможный апгрейд - увеличение версии самого Go. Тем более на прошлой неделе вышел Go11 RC1.
Ждем-с, когда добрые люди завалидируют :)

Инфраструктура следующая (для первой итерации)

SignalServer
Есть SignalServer - HTTPServer, который содержит список Node, которые запрашивали у него список соответствующих Node.
Сервер очень простой и совершенно пассивный. Если у него запросили список - он добавляет просившего, считая, что тот тоже теперь в сети,
и отдает список IP:Port для подключения к ним. Если Node решит отключиться от сети - он попытается послать сюда извещение убрать его из
списка - однако не всегда это возможно, поэтому этот список не реально активных Node, а тех, кто запрашивал этот список.

View
Это своего рода обрезаная Node - она может только пытаться сконектиться с другими Node. Сейчас она служит просто для тестирования,
в дальнешем это будет своего рода экземпляр IoT - то есть будет реализовано ServiceDiscovery и еще что-нибудь вкусное :)

Node
Полноценный элемент одноранговой сети. Дистрибутив содержит список адресов SignalServer, с которых узнает адреса прочих Node и пытается
захостить/соедениться с каждой из них напрямую. Если напрямую не получается (NAT и прочие прелести реального мира),
то соединение будет происходить через один из Proxy, список которых есть как в дистрибутиве, так и будет одним из типов данных, отдаваемых
SignalServer. В первой итерации этого не будет - есть много тем для отработки и без этого.

Proxy
Собственно обычный прокси-сервер, который служит для соединения Node, если они не могут построить прямое соединение.
В первой итерации его тоже не будет.

Config
Утилита для создания файла настроек для всех модулей и для каждого в частности. Данные будет хранить в JSON, просто потому, что в Go
с этим очень удобно (вроде как) и надо попробовать.
