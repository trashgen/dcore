Учебный проект, который поможет быстро въехать в Go. Проект - одноранговая сеть.
В проекте исползуются только стандартные библиотеки, за исключением:
1. github.com/mediocregopher/radix.v3 - для работы с Redis 3.2;
2. github.com/lib/pq - для работы с PostgreSQL 9.5.

Архитектура (на данный момент) следующая:
1. Config - генерирует несолько файлов с настройками для Поинта, Ноды, HTTP клиента;
2. Поинт - HTTP сервер, хранит в себе список Нод, которые подключились к системе. При подключении очередной Ноды - отдает ей список
   ключ/адрес/порт для подключения и инициализации P2P соединения (лайна);
3. Нода - рабочая лошадка системы. Умеет работать с HTTP сервером, отдавая ему при регистрации адрес своего хоста регистраций.
   В дальнейшем именно через него проходит первый контакт с другой Нодой и попытка создания лайна.


Описание модулей
1. Поинт. Хранит список информации по зарегестрированным Нодам. В Redis 3.2. Работы с Redis есть на уровне транзакций (MULTI/EXEC),
   так и почти аналогичный (но несколько по иному) функционал с помощью Lua script - что бы всё попробовать:
   1.1. В Redis информация хранится в виде Hash описаний подключения (hashkey:string; key:string, ip:string, port:int). Список Hashkey
        хранится в Unordered Set - таки образом реализовано получение всех hash - через SMEMBERS и далее в цикле HGETALL (MULTI/EXEC).
        Так же есть возможность получить ограниченное количество случайных hash - через SRANDMEMBER count и далее в цикле HGETALL
        (это сделано на Lua, и выполнение скрипта через EVALSHA);
   1.2. В PosgreSQL хранится список забаненых Нод (по IP) - просто чтобы была работа и с SQL и с NoSQL. Ничего интересного нет - просто
        одна таблица с (id:bigserial, ip:varchar(45)(возможность IPv6 адресов), created:timestamp; uniquekey(ip)).

   Доступные команды для Поинта (во всех, кроме reg есть параметр key - ключ самой Ноды, которая спрашивает. Для проверки):
   1.1. ip/reg?port=<int> - регистрация Ноды. Параметр - [port] для хоста регистраций. IP - получается из запроса через RemoteAddr
        для минимизации трафика;
   1.2. ip/look?key=<string>&numpoints=<int>&numnodes=<int> - получить список Нод (параметр numpoints пока игнорируется);
   1.3. ip/check?key=<string>&target=<strings> - запрос на проверку ключа [target] подключенца к хосту регистраций;
   1.4. ip/ban?key=<string>&ip=<strings> - если в процессе регистрации на хосте регистраций Ноды проверка [check] не прошла, то
        посылаю на Поинт [ip] обманщика;
   1.5. Удаляет Ноду с Поинта, если коннект к ней не прошел - то есть она была зарегестрирована, но видимо ушла. Пока не используется.
   1.6. ip/points?key=<string>&count=<int> - при реализации нескольких Поинтов - спрашивает адреса известных. Пока не используется.
        
2. Нода. Принцип создания лайна (P2P соединения с другой Нодой) следующий:
   2.1. При старте запускается хост регистраций, адрес которого хранится на Поинте после запроса [reg] - в ответ приходит ключ для этой
        Ноды на данную сессию. Следующая Нода после получения этого (и прочих подобных) адреса с помощью RegClient подключается к этому
        хосту и, если все проходит хорошо, то каждая из них поднимает хост для получения данных и создает подключение к другому хосту
        для отправки данных - полноценный лайн. За счет разделения канала на получание/отправку - эти процессы можно параллелить.

3. Клиент. Этот модуль - суть обертка над HTTP Client - необходимости в нем пока никакой, но есть идея сделать некую облегченную Ноду,
   которая будет соединятся только с такими же и readonly с полноценными (нечто типа Internet of Things). Но это все в будущем :)

Что планируется постепенно добавлять.
1. На данный момент идет активное изучение Docker overlay network - для создания полноценной тестовой среды. Пока получилось создавать
   несколько image через один Dockerfile и создавать из них независимые контейнеры для Поинта и Ноды. В кждом из них лежит так же Config,
   который генерирует конфиги для Всех модулей. Пока для всех - в дальнейшем, конечно, это будет ограничено через cmd params. Как только
   эта сеть заработает - будет подключена работа с Redis/PostgreSQL как отдельных хостов в тестовой среде - пока для Docker
   они заменены на Моки;
2. Небольшое изменение конфига для генерации файлов под конкретные нужды, а не всё для всех;
3. Добавление поддержки  многих Поинтов в системе, которые будут синхронизированы друг с другом и разные Ноды начинают со знанием не
   всех их. Будет происходит обновление конфига на стороне Ноды для последующего более быстрого доступа к подключенным к системе Нодам
   не только в рамках родного Поинта;
4. Изучение Redis master-slave, где мастер это отдельный хост, а рабы - на тех же что и Поинты. Синхронизация данных по Нодам будет
   проходить именно по этому пути, а не за счет внутренних HTTP запросов;
5. Повышение отказоустойчивости системы. Например, если одна Нода не может создать Лайн с другой - то вероятно, что это NAT - потому
   будет введен дополнительный модуль Прокси - цель которого - просто помогать Нодам общаться - правда, не напрямую, но все же.
6. Использование параметра максимальных Лайнов на Ноду - будет временно закрываться хост регистраций с сообщением Поинту и, как только,
   Другие Ноды будут уходить в оффлайн, то открывать регистрацию вновь (и говорить об этом Поинту).

Но в первую очередь - Docker. Понимание и небольшой опыт есть, но еще не все грабли собрал :)
ЗЫ. Вики практически не актуальна - будет время - поправлю.
